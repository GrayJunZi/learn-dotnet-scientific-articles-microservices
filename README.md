# learn-dotnet-scientific-articles-microservices

我们将从零开始构建真正的C#微服务和.NET 10解决方案中的模块化单体：一个完整的科学文章管理MVP。你将学习如何将领域驱动设计（DDD）和垂直切片架构应用于真实的业务工作流程——而非玩具示例。

你将看到如何将业务需求转化为有界上下文、聚合、价值对象和领域事件，然后用C#、ASP.NET Core、EF Core、gRPC、消息和Docker端到端实现它们。每个功能都构建为垂直切片：从API合同和验证，经过命令处理程序和域逻辑，再到持久化和测试。

我们实现了服务之间的同步和异步通信。你将学会区分核心/关键服务（使用直接的gRPC以提升可靠性）和领域服务（采用事件驱动架构并带有消息传递）。这让你在真实分布式系统中获得CQRS和事件驱动模式的实际经验。

在此过程中，我们关注实际架构决策：何时使用微服务，何时使用模块化单体，如何设计丰富的域而非“贫乏”模型，如何在 MediatR 上应用 CQRS，以及如何在服务通过 gRPC 和消息传递通信时保持代码干净、简洁且可测试。

## 一、介绍

### 1.1 技术栈

- 架构设计
    - 领域驱动设计（Domain-Driven Design, DDD）
    - 垂直切片架构（Vertical Slicing Architecture）
- 类库
    - .NET 10
    - Minimal API
    - MediatR
    - FastEndpoints
    - Carter
    - MassTransit
    - EF Core
    - GraphQL
    - Mapster
    - gRPC
    - Docker
- 数据存储
    - SQL Server
    - PostgreSQL
    - MongoDB
    - Redis

### 1.2 学习目标

**架构设计**

- 应用领域驱动设计来建模真实的业务需求。
- 使用垂直切片架构(Vertical Slicing Architecture)和整洁架构(Clean Architecture)来组织微服务。
- 根据需要设计模块化单体(Modular Monolith)并将其拆分为微服务。
- 使用c4图、序列流和战术ddd模式来可视化架构。

**实现模式**

- 使用 MediatR 和 FastEndpoints 来实现 CQRS 模式。
- 使用 SaveChangesInterceptor 实现领域驱动设计(Domain-Driven Design)。
- 应用事件驱动设计来解耦通信。

**API与通信**

- 使用 ASP.NET Core 和 Carter 来构建 Minimal APIs。
- 使用 gRPC 来实现同步通信。
- 使用 MassTransit 来实现异步通信。
- 集成 GraphQL 和 Hasura 来实现从 PostgreSQL 中高效查询数据。

**数据存储**

- 使用 SQL Server、PostgreSQL 和 Redis 存储数据。
- 使用 Mongo GridFS 存储文件。

**工具与基础设施**

- 使用 Mapster 或 AutoMapper 来映射 DTOs 和 集成事件(Integration Events)。
- 使用 .NET Identity 和 JWT 来实现用户认证和授权。
- 使用 Docker 来容器化应用程序。

## 二、技术概念与架构基础

### 2.1 什么是微服务？

微服务是一种架构风格，它将一个应用程序分解为多个小型、独立的服务，每个服务都运行在自己的进程中，并通过轻量级的通信机制（如 HTTP REST API / gRPC 或消息队列）进行通信。

微服务架构的主要优势包括：

- 每个服务都可以独立开发、部署和扩展。
- 服务之间的通信是异步的，这提高了系统的弹性和可伸缩性。
- 不同的服务可以使用不同的技术栈，这使得技术升级更加容易。

微服务的优势：

- 自治性(Autonomy)：
    - 独立(Independent)：每个服务在资源、运行时和基础设施上独立。
    - 解耦(Decoupled)：每个服务都有自己的数据库和业务逻辑，与其他服务解耦。
    - 弹性(Resilient)：每个服务都有自己的错误处理机制，如果一个服务失败，不会影响其他服务。这提高了系统的弹性。
- 高效运行(Efficiently)：
    - 独立部署(Deployable)：每个服务都可以独立部署，无需部署整个应用，这使得部署和升级更加容易。
    - 可伸缩性(Scalable)：每个服务都可以独立扩展，这使得系统可以根据需要进行水平扩展。
- 所有权(Ownership)：
    - 聚焦业务(Business Focused)：每个服务都有自己的团队负责开发和维护。
    - 团队专属 (Team Owned)：这使得服务的开发和维护更加独立和高效。
- 敏捷(Agile)：
    - 可适应性(Adaptable)：每个服务都可以根据需求进行迭代和改进。
    - 可组合性(Composable)：服务可以组合在一起，以构建更复杂的功能。这使得系统更加灵活和可扩展。


微服务面临的挑战：

- 数据一致性与同步：
    - 使用事件驱动或定时轮询来保持数据一致性。
    - 处理分布式事务和数据一致性问题。
- 多微服务场景下增加复杂度：
    - 审核服务接受文章
    - 支付服务等待支付
    - 支付服务确认支付
    - 生产服务接管最终处理
    - 文章中心确认文章状态变更
- 测试、调试与监控：
    - 设置复杂环境的测试
    - 监控需要关联技术

### 2.2 什么是模块化单体？

模块化单体是一种软件架构，其中应用程序被结构化为单个可部署单元，内部划分为具有清晰边界的封装良好(Well-Encapsulated)模块，每个模块负责应用程序的特定部分。

- 单一部署单元，所有组件均一起构建、测试并部署。
- 模块强制实施关注点分离，同时仍属于同一系统。
- 一个模块可以被多个服务集成，避免代码重复。
- 模块共享同一个数据，支持单事务操作。
- 模块之间通过函数调用或内存消息进行通信，而非HTTP或gRPC请求以提高系统的响应速度和吞吐量。

### 2.3 模块化单体与微服务的对比

- `Independence` - 多模块共享相同的运行环境。
- `Deployment` - 整个应用由多个模块组成的单元进行部署，而微服务独立部署。
- `Scalability` - 模块可以独立扩展，而微服务需要协调多个服务的扩展。
- `Communication` - 进程内通信更快，而微服务之间通信需要网络调用。
- `Data` - 数据隔离性更好，每个模块有自己的数据库，而微服务共享数据库。
- `Technology` - 模块可以使用不同的技术栈，而微服务需要协调多个服务的技术栈。

### 2.4 文件存储系统

- `GridFS` - 将文件存储至MongoDB中，支持标签和索引功能，速度慢于操作系统中的文件系统，因为存在数据库的额外开销。
- `MinIO` - 直接存储文件到磁盘中，速度更快，支持标签但不支持索引，实现了S3 API。
- `Azure Blob Storage` - 微软的云存储服务，提供高可用、高可扩展性的对象存储，支持标签和索引，成本较高。

**服务：**

- `Submission` - 提交服务，文件类型比较少，且上传和下载频率低，文件均为私有，保留策略较短，可以在一段时间之后删除或归档，因此无需大容量存储，性能要求也不高，但需要具有安全策略，因此 MongoDB 的 GridFS 方案更为适合。
- `Review` - 审核服务，包含所有提交文件，增加几种文件类型，其余和提交服务一样，因此可以使用相同的存储方案。
- `Production` - 生产服务，包含提交和查看的所有文件，新增多种文件类型并支持版本控制，文件不可删除，保留策略更长，因此需要高性能私有存储方案，如 MinIO。
- `PublicPages` - 公开页面服务，所有内容都是公开的，没有版本控制，可能会被大量下载，因此需要良好的性能而不需要很高的安全性，可以直接采用云存储方案。

#### 为什么文件存储是模块而不是微服务？

- `代码复杂度降低` - 因为文件存储嵌入在每个微服务中，意味着无需维护与部署独立的微服务。
- `更好的性能` - 文件操作无需向外部服务发送网络请求，这减少了延迟避免了服务间通信问题。
- `易于扩展` - 每个微服务都有自己的文件存储模块，存储能力随着服务的扩展而扩展。
- `存储访问规则` - 每个微服务中定义自己的存储访问规则，例如只读、读写等，这使得文件存储更加安全。
- `不同的存储策略` - 每个微服务可以根据自己的需求选择不同的存储策略，例如本地存储、云存储等。

#### 什么时候将文件存储作为微服务？

- 多个微服务需要共享文件存储时。
- 统一的文件存储服务，多个微服务可以通过调用该服务来进行文件存储和检索。


### 2.5 文章工作流程

1. 作者(Author)编写草稿文章。
2. 编辑(Editor)检查文章是否值得发表。
3. 若文章通过初步审核，编辑(Editor)邀请审稿人(Reviewer)进行审核并提供反馈。
4. 作者(Author)根据审稿人(Reviewer)的反馈进行修改，直到文章符合要求。
5. 编辑(Editor)再次审核文章，若通过，排版人员(Typesetter)将负责文章最终排版并确保多格式完美呈现。
6. 排版人员(Typesetter)完成排版后，将文章发布至公开页面服务(PublicPages)，并更新文章状态为已发布。

### 2.6 什么是领域驱动设计(DDD)？

DDD是一种帮助我们围绕现实世界问题构建软件的方法，在领域驱动设计的核心中存在一个简单但强大的概念：`Domain` 即领域。

#### 什么是领域？

领域驱动设计的核心思想是将软件构建围绕着业务领域进行，而不是技术实现。

- 领域是核心业务问题。
- 包含现实世界中的规则、约束和限制。

#### 领域驱动设计的核心支柱(Pillars)

1. 聚焦于业务(Business Focus)：DDD的核心在于对业务领域进行建模。
    - 帮助架构师设计更好的模型，帮助开发者理解业务需求。
2. 解决业务问题(Problem Solving)：DDD的目标是确保解决业务问题。
    - 关注业务需求，而不是实现细节。
3. 模型创建(Model Creation)：DDD强调使用业务语言来创建模型。
    - 良好的模型同时包含属性和行为，反应业务实际运作方式。
4. 限界上下文(Bounded Context)：DDD将系统分解为有界限的上下文区域，明确术语和规则。
    - 每个上下文都有自己的模型和业务逻辑，避免了不同上下文之间的混淆。
5. 事件驱动思考(Event-Driven Thinking)：DDD强调基于事件的通信，而不是传统的请求-响应模式。
    - 这使得系统更具弹性和可扩展性，能够处理复杂的业务场景。
6. 策略设计(Strategy Design)：DDD鼓励使用设计模式来解决业务问题。
    - 例如，策略模式(Strategy Pattern)用于定义算法族，使它们可以互换使用。